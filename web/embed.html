<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Truffle Billboard</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer"/>
        <link rel="stylesheet" href="style.css">
    </head>

    <body id="embed-body">
        <div class="hidden">
            <div id="edit-button" class="bb-parent bb-group">
                <i class="fa-solid fa-gear"></i>
            </div>
        </div>

        <div id="billboard"></div>

        <div id="edit-area" class="hidden">
            <div id="edit-header">
                <button id="edit-close"><i class="fa-solid fa-xmark"></i></button>
                <p>Truffle Billboard Settings</p>
            </div>
            <div id="editor"></div>
        </div>
        
        <script type="text/javascript" src="billboard.js"></script>
        <script type="module">
            import { embed, org as orgClient, getAccessToken } from "https://npm.tfl.dev/@trufflehq/sdk"

            let config;
            let groups = [];
            let curr;

            let interval;
            let timeout;

            let orgId;
            let editorOpen = false;

            const billboard = document.getElementById("billboard");
            const editButton = document.getElementById("edit-button");
            const editArea = document.getElementById("edit-area");

            function focusBillboard(config) {
                curr = 0;
                if(interval !== undefined) clearInterval(interval);
                if(timeout !== undefined) clearTimeout(timeout); // just in case two focuses occur within the timeout window

                // make sure edit button is showing if present
                if(!editorOpen) {
                    if(editButton.parentNode.scrollWidth > 0) {
                        embed.setStyles({
                            "margin": "12px 0 0 8px"
                        });
                    }
                    embed.setSize(editButton.parentNode.scrollWidth + "px", "36px");
                }
                
                groups.forEach(function(node) {
                    node.remove();
                });
                groups = [];

                config.groups.forEach(function(items) {
                    const group = createBillboardGroup(items);
                    group.classList.add("hidden");
                    groups.push(group);
                    billboard.appendChild(group);
                });

                if(groups.length > 0) {
                    const time = (config.interval == undefined ? 30 : config.interval) * 1000;

                    // we need to wait for groups to load before resizing embed
                    // we could use a resize observer, but thats pretty new and this works too
                    // https://stackoverflow.com/questions/61774434/how-to-wait-for-element-to-load-completely-into-dom
                    timeout = setTimeout(function() {
                        showNext();
                        if(groups.length > 1) interval = setInterval(showNext, time);
                    }, 1000);
                }
            }

            function showNext() {
                document.querySelectorAll("#billboard .bb-parent").forEach(function(node) {
                    node.classList.add("hidden");
                });

                const group = groups[curr++ % groups.length];
                group.classList.remove("hidden");

                if(!editorOpen) {
                    embed.setStyles({
                        "margin": "12px 0 0 8px"
                    });
                    embed.setSize((group.scrollWidth + editButton.parentNode.scrollWidth) + "px", "36px");
                }
            }

            function showLink(url, timeout) {
                focusBillboard({
                    interval: 1,
                    groups: [[{
                        type: "both",
                        link: url,
                        text: url,
                        icon: "fa-solid fa-link"
                    }]]
                });

                setTimeout(function() {
                    focusBillboard(config);
                }, timeout);
            }

            editButton.addEventListener("click", function() {
                if(interval !== undefined) clearInterval(interval);
                if(timeout !== undefined) clearTimeout(timeout);

                editButton.classList.add("hidden");
                billboard.classList.add("hidden");

                const iframe = document.createElement("iframe");
                iframe.src = "editor.html?org=" + orgId;
                document.getElementById("editor").appendChild(iframe); 
                
                editorOpen = true;

                embed.setStyles({
                    "margin": "0px",
                    "position": "fixed",
                    "top": "0px",
                    "left": "0px",
                    "transition": "none",
                    "z-index": "9999" // lol
                });
                embed.setSize("100%", "100%");

                editArea.classList.remove("hidden");
            });

            document.getElementById("edit-close").addEventListener("click", function() {
                embed.setSize("0px", "36px");
                embed.setStyles({
                    "position": "static",
                    "z-index": "auto",
                    "transition": "width 1s"
                });

                editButton.classList.remove("hidden");
                billboard.classList.remove("hidden");

                document.querySelector("#editor iframe").remove();
                editArea.classList.add("hidden");

                editorOpen = false;

                // showNext needs to be delayed like above
                if(timeout !== undefined) clearTimeout(timeout);
                timeout = setTimeout(function() {
                    embed.setStyles({
                        "margin": "12px 0 0 8px"
                    });
                    showNext();
                }, 1000);
            });

            const orgClientSubscription = orgClient.observable.subscribe({
                next: function(org) {
                    if(org == undefined) return;
                    orgId = org.id;

                    getAccessToken().then(function(value) {
                        fetch("/auth", {
                            method: "POST",
                            body: value
                        }).finally(connectSocket);
                    }).catch(connectSocket);

                    orgClientSubscription.unsubscribe();
                },
                error: function(error) {
                    console.error(error);
                },
                complete: function() {
                }
            });

            function connectSocket() {
                const socket = new WebSocket(encodeURI("ws://" + location.host + "/api?org=" + orgId));

                socket.addEventListener("message", function(event) {
                    const msg = JSON.parse(event.data);
                    if(msg.type == "update") {
                        if(msg.admin) editButton.parentNode.classList.remove("hidden");

                        if(msg.config !== undefined) {
                            config = msg.config;
                            focusBillboard(config);
                        }
                    } else if(msg.type == "link" && msg.link !== undefined && msg.timeout !== undefined) {
                        showLink(msg.link, msg.timeout);
                    }
                });
            }
        </script>
    </body>
</html>
